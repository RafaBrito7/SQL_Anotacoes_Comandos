<h1>SQL_Anotacoes_Comandos</h1>
<h2>Anotações do Curso de MySQL</h2>

<h3>*CRIANDO O BANCO DE DADOS*</H3>

  - ***CREATE DATABASE*** NAME_EXAMPLE;
  
<h3>*CONECTANDO-SE AO BANCO DE DADOS*</H3>

  - **USE** NAME_EXAMPLE;
  
<h3>*CRIANDO UMA TABELA CLIENTE*</H3>

  - **CREATE TABLE** CLIENTE(
      NOME VARCHAR(30),
      SEXO CHAR(1), (Exemplo de Tunning otimização de perfomance de um DB)
      EMAIL VARCHAR(30),
      CPF INT(11),
      TELEFONE VARCHAR(30),
      ENDERECO VARCHAR(100)
      );
			
<h3>*VERIFICANDO AS TABELAS DE UM BANCO*</H3>

  - **USE** NAME_EXAMPLE;
  - **SHOW** TABLES;
	
<h3>*DESCOBRINDO COMO É A ESTRUTURA (OS CAMPOS) DAS TABELAS*</H3>
	- **DESC* CLIENTE; 
	
<h3>*TUNNING DE TIPO DE DADOS - CHAR VS VARCHAR*</h3>

	- CHAR = UTILIZAR SEMPRE QUE O NÚMERO DE CARACTERES DA COLUNA NUNCA FOR VARIANTE OU SEJA, SEMPRE QUE FOR UMA CONSTANTE
		- EXEMPLO: SEXO / SIGLAS DE ESTADOS
		- É O QUE POSSUI MAIOR PERFOMANCE EM TEMPO DE PROCESSAMENTO
    
	- VARCHAR = É UM TIPO OTIMIZADO QUE SE ADAPTA A QUANTIDADE DE CARACTERES QUE ENTRAR, MESMO QUE SEJA DEFINIDO UM ESPAÇO DE 30
            CARACTERES, ELE UTILIZARÁ APENAS OS ESPAÇAMENTOS QUE FOREM INSERIDOS, OTIMIZANDO A PERFOMANCE DO BD
	
<h3>*TIPOS DE DADOS ENUM VS NUMERICOS*</h3>

	- ENUM = SÓ EXISTE NO MySQL E SERVE PARA EVITAR A INCOMPATIBILIDADE DE INFORMAÇÕES NO BANCO DE DADOS
		- EXEMPLO: NA ENTRADA DE SEXO HÁ OPÇÕES DIVERSAS COMO: "MASCULINO","M","MASC" E ETC PARA EVITAR PODEMOS FAZER UM 				
            TIPO ENUM QUE É UMA ESPÉCIE DE COMBOBOX OU SEJA UM CONJUNTO DELIMITADO DE VALORES
		- EM OUTROS BANCOS SE CHAMA CONSTRAINT DE CHECK
    
	- INT = NÚMEROS INTEIROS SEM VÍRGULA
		- MÁXIMO DE 11 DÍGITOS
    
	- FLOAT = NÚMEROS REAIS COM O USO DA VÍRGULA
		- EXEMPLO: FLOAT(total,virgula) = OU SEJA NÚMERO DE CASAS TOTAIS E DEPOIS QUANTOS NÚMEROS DEPOIS DA VÍRGULA
		- FLOAT(4,2) = 25,00 
		
<h3>*INSERINDO DADOS NA TABELA*</h3>

	- FORMA 1 = OMITINDO AS COLUNAS
		- INSERT INTO CLIENTE VALUES('JOÃO','M','JOAO@GMAIL.COM',988638273,'22923110','MARIA LACERDA - ESTACIO - RIO DE JANEIRO - RJ');
		- INSERT INTO CLIENTE VALUES('JORGE','M',NULL,885755896,'58748895','OSCAR CURY - BOM RETIRO - PATOS DE MINAS - MG);
    
	- FORMA 2 = COLOCANDO AS COLUNAS ( POSSIBILIDADE DE OMITIR COLUNAS - EXEMPLO EMAIL ABAIXO )
		- INSERT INTO CLIENTE(NOME,SEXO,ENDERECO,TELEFONE,CPF) VALUES ('LILIAN', 'F', 'SENADOR-SOARES - TIJUCA - RIO DE JANEIRO - RJ', '947785696', 887774856);
		
	- FORMA 3 = COMPACTO - EXCLUSIVO DO MySQL
    - INSERT INTO CLIENTE VALUES('ANA','F','ANA@GLOBO.COM',85548962,'548654254','PRES ANTONIO CARLOS - CENTRO - SAO PAULO -SP),
          ('CARLA','F','CARLA@TERATI.COM.BR',7745828,'66587458','SAMUEL SILVA - CENTRO - BELO HORIZONTE - MG');
          
   - SEMPRE SE ATENTAR PARA A DOCUMENTAÇÃO DOS TIPOS DE DADOS (EM TERMOS DE RANGE MAXIMO)
   
   - COMANDO BÁSICO DE UM DB = SELEÇÃO, PROJEÇÃO E JUNÇÃO
   
<h3>*COMANDO SELECT*</h3>
   
   	- COMANDO DE PROJEÇÃO, AO CONTRÁRIO DO QUE DIZ O NOME, ELE NÃO SERVE PARA SELECIONAR E SIM PARA PROJETAR PARA O USUÁRIO O QUE ELE DESEJAR.
	- SINTAXE DO COMANDO: SELECT NOME, SEXO, EMAIL FROM CLIENTE;
	- ALIAS SÃO ESPÉCIES DE APELIDOS QUE PODEMOS DAR PARA CAMPOS NA HORA DA PROJEÇÃO
		- EXEMPLO: SELECT NOME AS CLIENTE, EMAIL, SEXO FROM CLIENTE;
	- COMANDO PARA SELECIONAR TODOS OS DADOS DE UMA TABELA = SELECT * FROM CLIENTE;
		- ESSE COMANDO SÓ SERVE PARA FINS ACADÊMICOS, POIS NUM AMBIENTE DE TRABALHO O USUÁRIO ESCOLHE O QUE QUER PROJETAR, SENDO ASSIM SE É UTILIZADO UM SELECT * , TEMOS UM GRANDE AUMENTO NO TRÁFEGO DA REDE DE COMUNICAÇÃO ENTRE O DB E O SISTEMA E PRINCIPALMENTE NO TEMPO DE PROCESSAMENTO E DE RESPOSTA DO DB, POIS O USUÁRIO QUERIA A EXEMPLO 3 CAMPOS O QUE CUSTARIA 100BYTES DE PROCESSAMENTO E DE TRÁFEGO NA REDE, AO USAR O SELECT * NA TABELA CLIENTE TEREMOS 6 CAMPOS O QUE CUSTARIA 300 BYTES, DEIXANDO O SISTEMA MAIS LENTO E AFETANDO O TRÁFEGO DA NOSSA REDE DE COMUNICAÇÃO COM O DB
		
<h3>*COMANDO WHERE</h3>

	- COMANDO DE SELEÇÃO, SERVE PARA SELECIONARMOS UM OU MAIS REGISTRO PASSANDO UMA DECISÃO LÓGICA COMO ARGUMENTO
	- SINTAXE DO COMANDO: SELECT NOME,SEX FROM CLIENTE WHERE SEXO = 'M';
	- A PROJEÇÃO NÃO TEM NADA HAVER COM A SELEÇÃO
		EXEMPLO: SELECT NOME, ENDERECO FROM CLIENTE WHERER SEXO = 'F';
	- COMANDO LIKE, SERVE PARA FAZER PESQUISAS DENTRO DE UMA LINHA DE DADOS(TUPLA)
	- É NECESSÁRIO A UTILIZAÇÃO DE CARACTER CORINGA REPRESENTADO PELO %
		- EXEMPLO: 
			- 1 = BUSCAR DENTRO DA TUPLA NA COLUNA ENDEREÇO TODOS USUÁRIOS QUE MOREM NO ESTADO DO RJ
			- SELECT NOME, SEXO FROM CLIENTE WHERE ENDERECO LIKE '%RJ'; (PORQUE O ESTADO VEM POR ÚLTIMO NA COLUNA ENDEREÇO)
			
			- 2 = BUSCAR DENTRO DA TUPLA NA COLUNA ENDEREÇO TODOS USUÁRIOS QUE MOREM NA RUA OSCAR CURY
			- SELECT NOME, SEXO FROM CLIENTE WHERE ENDERECO LIKE 'OSCAR CURY%'; (PQ A RUA VEM PRIMEIRO)
			
			- 3 = BUSCAR DENTRO DA TUPLA NA COLUNA ENDEREÇO TODOS USUÁRIOS QUE MOREM NO BAIRRO CENTRO
			- SELECT NOME, SEXO FROM CLIENTE WHERE ENDERECO LIKE '%CENTRO%';
			
<h3>*COMANDO COUNT E GROUP/TUNNING*</h3>

	- FUNÇÃO DE AGREGAÇÃO QUE RETORNARÁ UMA SOMA
	- SINTAXE DO COMANDO: SELECT COUNT(*) AS "Quantidade de Registros" FROM CLIENTE;
	- COMANDO DE AGRUPAR UNIDA AO COUNT
	- SINTAZE DO COMANDO: SELECT SEXO, COUNT(*) FROM CLIENTE GROUP BY SEXO;
	- RETORNARÁ UMA TABELA MOSTRANDO A QUANTIDADE (COUNT) AGRUPADA PELO SEXO OU SEJA QUANTOS REGISTROS TEM EM CADA SEXO
	- EXEMPLO: M = 2 / F = 4
	- Exemplo de Tunning para Aumentar Perfomance do Banco:
		- Temos que primeiro conhecer bem os dados do nosso Banco de Dados
		- É recomendado o uso de um COUNT(*) para conhecermos os dados
		- E FILTRAR MATEMATICAMENTE PARA SABER PORCENTAGENS DOS DADOS
		- EXEMPLO: MEU COUNT DE SEXO E CIDADE RETORNOU DE 100 DADOS AGRUPADOS EM 70 F E 30 RJ
		- PARA TRABALHARMOS COM VALORES LÓGICOS OU CLAÚSULA WHERE TEMOS QUE TER EM MENTE O SEGUINTE
		- NO OR SÓ SERÁ FALSO QUANDO AMBOS FOREM FALSO, OU SEJA INDEPENDENTE DE POSIÇÃO, TODOS QUE TIVEREM PELO MENOS UM VERDADEIRO SERÁ VERDADEIRO
		- NO AND SÓ SERÁ VERDADEIRO QUANDO AMBOS FOREM VERDADEIRO, OU SEJA INDEPENDENTE DE POSIÇÃO, TODOS QUE TIVEREM PELO MENOS UM FASO SERÁ FALSO
		- TENDO EM VISTA ESSAS INFORMAÇÕES NUM WHERE ONDE É USADO UM OR
			- RECOMENDA-SE PARA TUNNING INICIARMOS A CLAÚSULA COM O SEXO POIS TEMOS 70% DE CHANCE DE SAIR VERDADEIRO
				- EXEMPLO: SELECT NOME,SEXO, FROM CLIENTE WHERE SEXO = 'F' OR CIDADE = 'RJ';
		- TENDO EM VISTA ESSAS INFORMAÇÕES NUM WHERE ONDE É USADO UM AND
			- RECOMENDA-SE PARA TUNNING INICIARMOS A CLAÚSULA COM A CIDADE POIS TEMOS 30% DE CHANCE DE SAIR VERDADEIRO E SERÁ OBRIGATÓRIO O BANCO EXAMINAR AMBAS A VARIÁVEIS POIS PRECISAMOS QUE AMBSO SEJAM VERDADEIRO PARA DAR VERDADEIRO, ENTÃO ELE IRÁ FAZER A REQUISIÇÃO 30% DAS VEZES, POIS É A QUE VAI DAR VERDADEIRO
				- EXEMPLO: SELECT NOME,SEXO, FROM CLIENTE WHERE CIDADE = 'RJ' AND SEXO = 'F';
				
	**OBS: SEMPRE EVITAR O RETRABALHO DA CHECAGEM LÓGICA DA SEGUNDA CONDIÇÃO**
	
<h3>FILTRANDO VALORES NULOS</h3>

	- DIFERENTE DOS OUTROS TIPOS DE DADOS, O NULL ELE NÃO ARMAZENA NADA PARA SER COMPARADO COM OUTRO (OU SEJA COM SINAL DE "=")
	- PARA RETORNAR OS CLIENTES QUE POSSUEM O EMAIL NULO FAZEMOS O SEGUINTE:
		- SELECT NOME, SEXO, ENDERECO FROM CLIENTE WHERE EMAIL IS NULL;
	- DA MESMA FORMA PARA RETORNAR OS CLIENTES QUE NÃO POSSUEM O EMAIL NULO FAREMOS O SEGUINTE:
		- SELECT NOME, SEXO, ENDERECO FROM CLIENTE WHERE EMAIL IS NOT NULL;

<h3>ATUALIZANDO REGISTROS</h3>

	- PARA ATUALIZAR REGISTRO É SEMPRE IMPORTANTE LEMBRAR DE UTILIZAR 2 COMANDOS PRINCIPAIS, O SELECT (PARA CONFIRMAR SE REALMENTE É AQUELE ROW QUE VOCÊ QUER ATUALIZAR) E O WHERE (PARA QUE NÃO SETEMOS TODOS OS ROWS DO BANCO)
	- SINTAXE DO COMANDO:
		- SELECT * FROM CLIENTE WHERE NOME = 'LILIAN'; (CONFIRMANDO OS DADOS QUE QUEREMOS SETAR)
		- UPDATE CLIENTE SET EMAIL = 'LILIAN@GMAIL.COM' WHERE NOME = 'LILIAN'; (SEMPRE USAR WHERE PARA N SETAR TODO O BD)
   
  <h3>DELETANDO REGISTROS</h3>
  	
	- PARA DELETAR REGISTRO É SEMPRE IMPORTANTE LEMBRAR DE UTILIZAR 2 COMANDOS PRINCIPAIS, O SELECT (PARA CONFIRMAR SE REALMENTE É AQUELE ROW QUE VOCÊ QUER DELETAR) E O WHERE (PARA QUE NÃO DELETEMOS TODOS OS ROWS DO BANCO)
	- É INTERESSANTE TAMBÉM UTILIZAR O COMANDO COUNT COM O WHERE PARA QUE SAIBAMOS EXATAMENTE QUANTOS REGISTROS VAMOS DELETAR DO NOSSO BANCO.
	- EXEMPLO:
		SELECT COUNT(*) FROM CLIENTE WHERE NOME = 'ANA';
	- COM ESSE EXEMPLO ACIMA SABEREMOS COM EXATIDÃO QUANTOS REGISTROS POSSUEM NO NOSSO BANCO COM O FILTRO PASSADO NA CLÁUSULA WHERE
	- DELETE SINTAXE DO COMANDO:
		- DELETE FROM CLIENTE WHERE NOME = 'ANA';
	- DICA: CASO HAJA MUITOS DADOS RETORNADOS PELO COUNT, E QUEREMOS SABER QUANTOS ROWS SOBRARAM APÓS O DELETE, PODEMOS FAZER CONTAS MATEMÁTICAS DENTRO DO TERMINAL DO MySQL, SEM AFETAR EM NADA O NOSSO BANCO
		- EXEMPLO: SELECT 6 - 1;
   
   <h3>MODELAGEM DE BANCODADOS</h3>

	- PRIMEIRA FORMA NORMAL
		- REGRA 1 = TODO CAMPO VETORIZADO SE TORNARÁ UMA OUTRA TABELA
			- EX: CAMPO TELEFONE ( PODEM TER + DE 1 TELEFONE)
		- REGRA 2 = TODO CAMPO MULTIVALORADO SE TORNARÁ UMA NOVA TABELA OU QUANDO O CAMPO FOR DIVISÍVEL
			- EX: CAMPO ENDEREÇO (POSSUI MULTIVALORES DE TIPO DIFERENTE: RUA CIDADE ESTADO ETC)
		- REGRA 3 = TODA TABELA NECESSITA DE PELO MENOS UM CAMPO QUE IDENTIFIQUE TODO O REGISTRO COMO SENDO ÚNICO (PK)
			- NUNCA SE MODELA BASEADO EM NEGÓCIOS OU SEJA UM CPF NÃO PODE SER PK POIS UM DIA PODE ACONTECER DE MUDAR, É ALGO QUE NÃO TEMOS CONTROLE SOBRE, O CPF É UMA CHAVE NATURAL MAS PRECISAMOS DE UMA CHAVE ARTIFICIAL, QUE TENHAMOS TOTAL CONTROLE
			
	- CARDINALIDADE
		A CARDINALIDADE ESTÁ RELACIONADA A RELAÇÃO ENTRE OBRIGATORIEDADE E CARDINALIDADE_MÁXIMA.
		FUNCIONA DA SEGUINTE MANEIRA, PODEREMOS TER EM UM RELACIONAMENTO A SEGUINTE CARDINALIDADE:
			- (0,n) , (0,1), (1,n), (1,1)
			- A PRIMEIRA COLUNA DO PAR, É DEFINIDA PELA OBRIGATORIEDADE OU SEJA, SE FOR OBRIGADO É 1 (TRUE) SE NÃO É 0 (FALSE), COM ISSO TEMOS MONTADO A NOSSA PRIMEIRA COLUNA DO NOSSO PAR
			- A SEGUNDA COLUNA, É DEFINIDA PELA QUANTIDADE_MÁXIMA, OU SEJA, É PERMITIDO ADICIONAR MAIS DE 1 OU APENAS 1? SE FOR PERMITIDO ADICIONAR APENAS 1, O SEGUNDO PAR É 1, SE NÃO, O SEGUNDO PAR É N .
			EX: 
				ENDEREÇO = OBRIGATÓRIO O CADASTRO DE UM ENDEREÇO (NO MÁXIMO 1)
				TELEFONE = O CLIENTE NÃO É OBRIGADO A INFORMAR TELEFONE, MAS PODE INFORMAR MAIS DE UM CASO QUEIRA
			- PARA UMA TABELA CLIENTE, QUE SE RELACIONA COM AMBAS ENTIDADES, TEREMOS A SEGUINTE CARDINALIDADE:
				ENDERECO -> CLIENTE (1,1) / TELEFONE -> CLIENTE (0,n)
			- JÁ PARA FAZERMOS A CARDINALIDADE INVERSA, QUE É PARA SABER QUANTOS ENDEREÇOS OU TELEFONES O CLIENTE PODE TER
				- É OBRIGATÓRIO UM ENDEREÇO TER UM CLIENTE? SIM ENTÃO 1
				- NO MÁXIMO QUANTOS CLIENTES PODEM TER AQUELE ENDEREÇO? NO MÁXIMO 1
				- É OBRIGATÓRIO UM TELEFONE TER UM CLIENTE? SIM ENTÃO 1
				- NO MÁXIMO QUANTOS CLIENTES PODEM TER AQUELE TELEFONE? NO MÁXIMO 1
				CLIENTE -> ENDEREÇO (1,1) / CLIENTE -> TELEFONE (1,1)
			- COM ISSO PODEREMOS DEFINIR O RELACIONAMENTO FINAL:
				- SEMPRE USAREMOS O SEGUNDO PAR PARA ESTABELECER A CARDINALIDADE FINAL, PARTINDO SEMPRE DA ENTIDADE CENTRAL QUE NESSE CASO É CLIENTE
			- CLIENTE -> ENDERECO (1,1)
			- CLIENTE -> TELEFONE (1,n)
			
<h3>FOREIGN KEY - CHAVE ESTRANGEIRA</h3>

		-  É UMA CHAVE PRIMÁRIA DE UMA TABELA, QUE VAI A OUTRA TABELA FAZER REFERÊNCIA DA OUTRA TABELA.
		- DEPENDERÁ DIRETAMENTE DA CARDINALIDADE FINAL, SEGUINDO AS SEGUINTES REGRAS:
			- EM UM RELACIONAMENTO 1X1 A CHAVE ESTRANGEIRA FICA NA TABELA MAIS FRACA
				- A TABELA MAIS FRACA É DEFINIDA PELA REGRA DE NEGÓCIO ( NO CASO DE UM NEGÓCIO DE UM ESTACIONAMENTO, QUAL TABELA SERIA A MAIS IMPORTANTE, A DE UM CARRO OU A DE UM CLIENTE? A MAIS IMPORTANTE SERIA A DE UM CARRO, TORNANDO-A ASSIM A MAIS FORTE, E A DE CLIENTE A MAIS FRACA
			- EM UM RELACIONAMENTO 1 X N  A CHAVE ESTRANGEIRA FICARÁ SEMPRE NA CARDINALIDADE N
		- SINTAXE DENTRO DO CREATE TABLE
		
			CASO SEJA 1 X N
			FK_CLIENTE INT,
			FOREIGN KEY(FK_CLIENTE)
			REFERENCES CLIENTE(ID_CLIENTE)
			
			CASO SEJA 1X1
			FK_CLIENTE INT UNIQUE,
			FOREIGN KEY(FK_CLIENTE)
			REFERENCES CLIENTE(ID_CLIENTE)
